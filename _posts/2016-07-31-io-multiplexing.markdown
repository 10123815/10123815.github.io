---
layout:     post
title:      "I/O复用"
date:       2016-07-31
author:     "ysd"
header-img: "img/post-bg-2015.jpg"
tags:      
        - tcp
        - io
---

### I/O模型

##### 阻塞式I/O

![](/img/in-post/2016-07-31-io/bio.png)
进程调用recvfrom，其系统调用直到数据报到达且被拷贝到应用进程的缓冲区中或者发生错误才返回。
最常见的错误是系统调用被信号中断。
我们说进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据。

##### 非阻塞式I/O

![](/img/in-post/2016-07-31-io/nbio.png)
前三次调用recvfrom时没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。
第四次调用recvfrom时已有数据报准备好，它被拷贝到应用进程缓冲区，recvfrom于是成功返回。我们接着处理数据。
当一个应用进程像这样对一个非阻塞描述字循环调用recvfrom时，我们称之为轮询（polling）。
应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间，不过这种模型偶尔也会遇到，通常是在只专门提供某种功能的系统中才有。

##### I/O复用

![](/img/in-post/2016-07-31-io/iomp.png)
_阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。_
使用select的优势在于我们可以等待多个描述字就绪。

##### 信号驱动式I/O

![](/img/in-post/2016-07-31-io/sigio.png)
我们首先开启套接口的信号驱动I/O功能，并通过sigaction系统调用安装一个信号处理函数。
该系统调用立即返回，我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。
我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。

##### 异步I/O

![](/img/in-post/2016-07-31-io/aio.png)
信号驱动I/O是由内核通知我们何时启动一个I/O操作，_而异步I/O模型是由内核通知我们I/O操作何时完成。_
该系统调用立即返回，在等待I/O完成期间，我们的进程不被阻塞。

##### 比较
![](/img/in-post/2016-07-31-io/cmp.png)
