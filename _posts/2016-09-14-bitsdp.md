---
layout:     post
title:      "数位dp"
date:       2016-09-14
author:     "ysd"
header-img: "img/post-bg-2015.jpg"
tags:      
        - algorithm
---

#### Example 1: Amount of Degrees

>求给定区间[X, Y]中满足下列条件的整数个数：这个数恰好等于K个互不相等的B的整数次幂的和。其中 2 <= B <= 10。
如指定[15, 20]，K=2，B=2，有三个数满足：          
17=2^4+2^0 18=2^4+2^1 20=2^4+2^2  因此输出 3                         
[原题在这](http://acm.timus.ru/problem.aspx?space=1&num=1057)

此题只需求[0, Y]和[0, X - 1]的解，然后相减即可；               
可以看出满足条件的数其实是一个B进制的表示，且系数只能为0或1。

对于2进制，相当于求某些数字的二进制表示上，有K个位为1，这样的数的个数;              
例如n=13,k=3时，13（1101）有4位，即在下面的01树的第4层（根为第0层）找出整条路径有3个1的路径总数；               
但实际上有些数满足条件但比13大，比如14（1110），因此还需做其他的处理。

![](/img/in-post/2016-09-15-bitsdp/amount-degrees.png)
设一个2维数组，`dp[i][j]`，表示一个i位的2进制数（其实更应该理解为一个长度为i的01串）中，有j位为1的数的个数，则

```markdown
初始时有：dp[0][0] = 1, dp[0][1] = 0;
第i层至多有i个1，即j<=i;
dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; // 已有的i-1位有j个1，第i位为0，或已有的i-1位有j-1个1，再来一个1
```

对于进制大于2，由于要求系数为0或1，所以可以转化为2进制；          
实际上，当某个数的k进制中有一位的系数大于1，则只需将这一位极其第位全置为1即可（这样就是小于等于原数的最大的满足条件的数）

{% highlight java linenos %}
vector<vector<int>> dp(33, vector<int>(33, 0));

void init() {
	dp[0][0] = 1;
	for (int i = 1; i <= 32; i++) {
		dp[i][0] = dp[i - 1][0];
		for (int j = 1; j <= i; j++) {
			dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];
		}
	}
}
int amountOfDegrees(int n, int b, int k) {

	int bits = 0;
	vector<int> coe;
	while (n) {
		coe.push_back(n % b);
		n /= b;
		bits++;
	}

	int count = 0;
	int ans = 0;

	for (int i = bits - 1; i >= 0; i--) {
		if (coe[i] > 1) {
			ans += dp[i + 1][k - count];
		} else if (coe[i] == 1) {
			ans += dp[i][k - count];
			if (++count == k) break;
		}
	}

	if (count == k) ans++;
	return ans;

}
{% endhighlight %}
